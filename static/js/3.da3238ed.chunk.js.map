{"version":3,"sources":["components/movies-list/MoviesList.module.css","components/movies-list/pages/Pages.module.css","../node_modules/framer-motion/dist/es/components/AnimateSharedLayout/utils/crossfader.js","../node_modules/framer-motion/dist/es/animation/animate.js","../node_modules/framer-motion/dist/es/components/AnimateSharedLayout/utils/stack.js","../node_modules/framer-motion/dist/es/components/AnimateSharedLayout/index.js","../node_modules/framer-motion/dist/es/components/AnimateSharedLayout/utils/rotate.js","components/movies-list/pages/Pages.jsx","components/movies-list/MoviesList.jsx"],"names":["module","exports","createCrossfader","progress","motionValue","options","lead","undefined","follow","crossfadeOpacity","preserveFollowOpacity","prevOptions","__assign","leadState","followState","isActive","finalCrossfadeFrame","prevUpdate","startCrossfadeAnimation","target","transition","hasUpdated","onUpdate","scheduleRender","onComplete","getFrameData","timestamp","getValueTransition","from","to","value","isMotionValue","startAnimation","stop","animate","set","sync","read","updateCrossfade","_a","_b","latestLeadValues","getLatestValues","Object","assign","latestFollowValues","prevValues","p","get","leadTargetOpacity","opacity","followTargetOpacity","mix","isVisible","easeCrossfadeIn","easeCrossfadeOut","hasFollowElement","i","numBorders","borderLabel","borders","followRadius","getRadius","leadRadius","radius","Math","max","rotate","backgroundColor","mixColor","mixValues","Boolean","fromLead","toLead","initialProgress","reset","getCrossfadeState","element","setOptions","newOptions","compress","circOut","linear","min","easing","length","values","radiusName","borderRadius","layoutStack","prevViewportBox","prevDragCursor","stack","Set","state","leadIsExiting","prevState","crossfader","needsCrossfadeAnimation","add","setCrossfader","remove","delete","getLead","updateSnapshot","dragControls","elementDragControls","isDragging","cursorProgress","clearSnapshot","updateLeadAndFollow","order","Array","presence","Presence","Exiting","isPresenceRoot","child","shouldCrossfade","pointTo","setVisibility","config","prevParent","getProjectionParent","Entering","originBox","targetBox","getLayoutState","layout","getFollowLayout","getDefaultTransition","notifyLayoutReady","AnimateSharedLayout","_super","_this","apply","this","arguments","children","stacks","Map","hasMounted","updateScheduled","renderScheduled","syncContext","createBatcher","syncUpdate","force","scheduleUpdate","forceUpdate","register","addChild","removeChild","__extends","prototype","componentDidMount","componentDidUpdate","startLayoutAnimation","shouldComponentUpdate","type","props","forEach","isPresent","Present","updateStacks","handler","layoutReady","getLayoutId","getStack","parent","context","visualElement","flush","hasRotate","resetValues","transformAxes","key","hasValue","getStaticValue","setStaticValue","syncRender","resetRotate","shouldResetTransform","resetTransform","snapshotViewportBox","addToStack","removeFromStack","id","has","render","React","SharedLayoutContext","Provider","contextType","MotionContext","Pages","pages","currentPage","useSelector","movies","dispatch","useDispatch","className","style","pageNumbers","map","pageNum","PageButton","pageNumber","clickHandler","changePage","onClick","link","motion","div","layoutId","selectedPage","spring","stiffness","damping","MoviePreview","lazy","MoviesList","queryResult","queryResultMovies","total_pages","_","index","useParams","useEffect","queryMovies","movieListContent","pagesConstraint","moviesResult","Suspense","fallback","Loader","results","movie","previewConstraint"],"mappings":"2GACAA,EAAOC,QAAU,CAAC,iBAAmB,qCAAqC,MAAQ,0BAA0B,WAAa,+BAA+B,aAAe,iCAAiC,gBAAkB,sC,oBCA1ND,EAAOC,QAAU,CAAC,YAAc,2BAA2B,cAAc,2BAA2B,KAAO,oBAAoB,aAAe,8B,sQCM9I,SAASC,IAIL,IAAIC,EAAWC,YAAY,GACvBC,EAAU,CACVC,UAAMC,EACNC,YAAQD,EACRE,kBAAkB,EAClBC,uBAAuB,GAEvBC,EAAcC,YAAS,GAAIP,GAC3BQ,EAAY,GACZC,EAAc,GAIdC,GAAW,EAIXC,EAAsB,KAItBC,EAAa,EACjB,SAASC,EAAwBC,EAAQC,GACrC,IAAId,EAAOD,EAAQC,KAAME,EAASH,EAAQG,OAC1CO,GAAW,EACXC,EAAsB,KACtB,IAAIK,GAAa,EACbC,EAAW,WACXD,GAAa,EACbf,GAAQA,EAAKiB,iBACbf,GAAUA,EAAOe,kBAEjBC,EAAa,WACbT,GAAW,EAKXC,EAAsBS,cAAeC,WAGzC,OADAN,EAAaA,GAAcO,YAAmBP,EAAY,aCpBlE,SAAiBQ,EAAMC,EAAIT,QACJ,IAAfA,IAAyBA,EAAa,IAC1C,IAAIU,EAAQC,YAAcH,GAAQA,EAAOxB,YAAYwB,GAErD,OADAI,YAAe,GAAIF,EAAOD,EAAIT,GACvB,CACHa,KAAM,WAAc,OAAOH,EAAMG,SDgB1BC,CAAQ/B,EAAUgB,EAAQP,YAASA,YAAS,GAAIQ,GAAa,CAAEE,SAAUA,EAAUE,WAAY,WACzFH,EASDG,KARArB,EAASgC,IAAIhB,GAKbiB,IAAKC,KAAKb,IAKdF,QAGZ,SAASgB,IACL,IAAIC,EAAIC,EAMJd,EAAYD,cAAeC,UAC3BpB,EAAOD,EAAQC,KAAME,EAASH,EAAQG,OAC1C,GAAIkB,IAAcT,GAAeX,EAAjC,CAEAW,EAAaS,EAKb,IAAIe,EAAmBnC,EAAKoC,kBAC5BC,OAAOC,OAAO/B,EAAW4B,GACzB,IAAII,EAAqBrC,EACnBA,EAAOkC,kBACPrC,EAAQyC,WACdH,OAAOC,OAAO9B,EAAa+B,GAC3B,IAAIE,EAAI5C,EAAS6C,MAKbC,EAAwD,QAAnCV,EAAKE,EAAiBS,eAA4B,IAAPX,EAAgBA,EAAK,EACrFY,EAAoI,QAA7GX,EAA4B,OAAvBK,QAAsD,IAAvBA,OAAgC,EAASA,EAAmBK,eAA4B,IAAPV,EAAgBA,EAAK,EACjKnC,EAAQI,kBAAoBD,GAC5BK,EAAUqC,QAAUE,aAKC,IAArB5C,EAAO6C,UAAsB,EAAIF,EAAqBF,EAAmBK,EAAgBP,IACzFjC,EAAYoC,QAAU7C,EAAQK,sBACxByC,EACAC,YAAID,EAAqB,EAAGI,EAAiBR,KAE7CvC,IACNK,EAAUqC,QAAUE,YAAID,EAAqBF,EAAmBF,IAkE5E,SAAmBlC,EAAWC,EAAa2B,EAAkBI,EAAoBW,EAAkBT,GAI/F,IAAK,IAAIU,EAAI,EAAGA,EAAIC,EAAYD,IAAK,CACjC,IAAIE,EAAc,SAAWC,EAAQH,GAAK,SACtCI,EAAeC,EAAUjB,EAAoBc,GAC7CI,EAAaD,EAAUrB,EAAkBkB,GAC7C,SAAqBpD,IAAjBsD,QAA6CtD,IAAfwD,KAElCF,IAAiBA,EAAe,GAChCE,IAAeA,EAAa,GAMA,kBAAjBF,GACe,kBAAfE,GAAyB,CAChC,IAAIC,EAASC,KAAKC,IAAId,YAAIS,EAAcE,EAAYhB,GAAI,GACxDlC,EAAU8C,GAAe7C,EAAY6C,GAAeK,GAM5D,GAAInB,EAAmBsB,QAAU1B,EAAiB0B,OAAQ,CACtD,IAAIA,EAASf,YAAIP,EAAmBsB,QAAU,EAAG1B,EAAiB0B,QAAU,EAAGpB,GAC/ElC,EAAUsD,OAASrD,EAAYqD,OAASA,GASvCX,GACDf,EAAiB2B,iBACjBvB,EAAmBuB,kBAOnBvD,EAAUuD,gBAAkBtD,EAAYsD,gBAAkBC,YAASxB,EAAmBuB,gBAAiB3B,EAAiB2B,gBAA9DC,CAA+EtB,IA9GzIuB,CAAUzD,EAAWC,EAAa2B,EAAkBI,GAAsB,GAAI0B,QAAQ/D,GAASuC,IAEnG,MAAO,CACHhC,SAAU,WACN,OAAOF,IACFE,GAAYU,cAAeC,YAAcV,IAElDwD,SAAU,SAAUpD,GAChB,OAAOF,EAAwB,EAAGE,IAEtCqD,OAAQ,SAAUrD,GACd,IAAIsD,EAAkB,EAetB,OAdKrE,EAAQyC,YAAezC,EAAQG,OAM3BG,EAAYL,OAASD,EAAQG,QAClCG,EAAYH,SAAWH,EAAQC,OAI/BoE,EAAkB,EAAIvE,EAAS6C,OAP/B0B,EAAkB,EAStBvE,EAASgC,IAAIuC,GACNxD,EAAwB,EAAGE,IAEtCuD,MAAO,WAAc,OAAOxE,EAASgC,IAAI,IACzCF,KAAM,WAAc,OAAO9B,EAAS8B,QACpC2C,kBAAmB,SAAUC,GAEzB,OADAvC,IACIuC,IAAYxE,EAAQC,KACbO,EAEFgE,IAAYxE,EAAQG,OAClBM,OADN,GAITgE,WAAY,SAAUC,GAClBpE,EAAcN,EACdA,EAAU0E,EACVlE,EAAY,GACZC,EAAc,IAElB4B,gBAAiB,WACb,OAAO7B,IAInB,IAAIyC,EAAkB0B,EAAS,EAAG,GAAKC,KACnC1B,EAAmByB,EAAS,GAAK,IAAME,KAC3C,SAASF,EAASG,EAAKjB,EAAKkB,GACxB,OAAO,SAAUrC,GAEb,OAAIA,EAAIoC,EACG,EACPpC,EAAImB,EACG,EACJkB,EAAOjF,YAASgF,EAAKjB,EAAKnB,KAGzC,IAAIa,EAAU,CAAC,UAAW,WAAY,aAAc,eAChDF,EAAaE,EAAQyB,OAkDzB,SAASvB,EAAUwB,EAAQC,GACvB,IAAIhD,EACJ,OAAqC,QAA7BA,EAAK+C,EAAOC,UAAgC,IAAPhD,EAAgBA,EAAK+C,EAAOE,aE5N7E,SAASC,IACL,IAGI3C,EACA4C,EACAC,EALAC,EAAQ,IAAIC,IACZC,EAAQ,CAAEC,eAAe,GACzBC,EAAYpF,YAAS,GAAIkF,GAIzBG,EAAa/F,IACbgG,GAA0B,EAQ9B,MAAO,CACHC,IAAK,SAAUtB,GACXA,EAAQuB,cAAcH,GACtBL,EAAMO,IAAItB,GAINc,IACAd,EAAQc,eAAiBA,GACxBG,EAAMxF,OACPwF,EAAMxF,KAAOuE,IAErBwB,OAAQ,SAAUxB,GACde,EAAMU,OAAOzB,IAEjB0B,QAAS,WAAc,OAAOT,EAAMxF,MACpCkG,eAAgB,WACZ,GAAKV,EAAMxF,KAAX,CAEAwC,EAAamD,EAAWlF,WAClBkF,EAAWvD,kBACXoD,EAAMxF,KAAKoC,kBACjBgD,EAAkBI,EAAMxF,KAAKoF,gBAC7B,IAAIe,EAAeC,IAAoB1D,IAAI8C,EAAMxF,MAC7CmG,GAAgBA,EAAaE,aAC7BhB,EAAiBc,EAAaG,kBAGtCC,cAAe,WACXlB,EAAiBD,OAAkBnF,GAEvCuG,oBAAqB,WACjB,IAAIvE,EAEAjC,EACAE,EAFJwF,EAAYpF,YAAS,GAAIkF,GAIzB,IADA,IAAIiB,EAAQC,MAAMpF,KAAKgE,GACdnC,EAAIsD,EAAM1B,OAAQ5B,IAAKA,GAAK,EAAG,CACpC,IAAIoB,EAAUkC,EAAMtD,GAIpB,GAHInD,IACW,OAAXE,QAA8B,IAAXA,IAA8BA,EAASqE,IACrD,OAATvE,QAA0B,IAATA,IAA0BA,EAAOuE,GAC9CvE,GAAQE,EACR,MAERsF,EAAMxF,KAAOA,EACbwF,EAAMtF,OAASA,EACfsF,EAAMC,eAAuC,QAArBxD,EAAKuD,EAAMxF,YAAyB,IAAPiC,OAAgB,EAASA,EAAG0E,YAAcC,IAASC,QACxGlB,EAAWnB,WAAW,CAClBxE,KAAMA,EACNE,OAAQA,EACRsC,WAAYA,EACZrC,kBAA8B,OAAXD,QAA8B,IAAXA,OAAoB,EAASA,EAAO4G,kBAA6B,OAAT9G,QAA0B,IAATA,OAAkB,EAASA,EAAK8G,kBAKnJtB,EAAMxF,OAAS0F,EAAUxF,QACpBwF,EAAU1F,OAASwF,EAAMxF,MACtB0F,EAAUD,gBAAkBD,EAAMC,gBACtCG,GAA0B,IAGlChE,QAAS,SAAUmF,EAAOC,GACtB,IAAI/E,EAEJ,QADwB,IAApB+E,IAA8BA,GAAkB,GAChDD,IAAUvB,EAAMxF,KAAM,CAClBgH,EAKAD,EAAME,QAAQzB,EAAMxF,MAGpB+G,EAAMG,eAAc,GAExB,IAAIC,EAAS,GACTC,EAAqC,QAAvBnF,EAAKuD,EAAMtF,cAA2B,IAAP+B,OAAgB,EAASA,EAAGoF,sBAa7E,GAZID,IAIAD,EAAOC,WAAaA,GAEpBL,EAAMJ,WAAaC,IAASU,SAC5BH,EAAOI,UA5FZ/B,EAAMtF,OAASsF,EAAMtF,OAAOkF,gBAAkBA,EA8FpC2B,EAAMJ,WAAaC,IAASC,UACjCM,EAAOK,UA7FvB,WACI,IAAIvF,EACJ,OAA+B,QAAvBA,EAAKuD,EAAMtF,cAA2B,IAAP+B,OAAgB,EAASA,EAAGwF,iBAAiBC,OA2FrDC,IAEnB/B,EAAyB,CACzBA,GAA0B,EAC1B,IAAI9E,EAAaiG,EAAMa,uBACvBb,EAAMJ,WAAaC,IAASU,SACtB3B,EAAWxB,OAAOrD,GAClB6E,EAAWzB,SAASpD,GAE9BiG,EAAMc,kBAAkBV,QAGpBH,EACAxB,EAAMxF,MAAQ+G,EAAME,QAAQzB,EAAMxF,MAGlC+G,EAAMG,eAAc,K,gDCjHpCY,EAAqC,SAAUC,GAE/C,SAASD,IACL,IAAIE,EAAmB,OAAXD,GAAmBA,EAAOE,MAAMC,KAAMC,YAAcD,KAkChE,OA9BAF,EAAMI,SAAW,IAAI7C,IAMrByC,EAAMK,OAAS,IAAIC,IAKnBN,EAAMO,YAAa,EAKnBP,EAAMQ,iBAAkB,EAIxBR,EAAMS,iBAAkB,EAIxBT,EAAMU,YAAcpI,YAASA,YAAS,GAAIqI,eAAkB,CAAEC,WAAY,SAAUC,GAAS,OAAOb,EAAMc,eAAeD,IAAWE,YAAa,WAGzIf,EAAMU,YAAcpI,YAAS,GAAI0H,EAAMU,aACvCV,EAAMc,gBAAe,IACtBE,SAAU,SAAUjC,GAAS,OAAOiB,EAAMiB,SAASlC,IAAWhB,OAAQ,SAAUgB,GAAS,OAAOiB,EAAMkB,YAAYnC,MAClHiB,EA0IX,OA9KAmB,YAAUrB,EAAqBC,GAsC/BD,EAAoBsB,UAAUC,kBAAoB,WAC9CnB,KAAKK,YAAa,GAEtBT,EAAoBsB,UAAUE,mBAAqB,WAC/CpB,KAAKqB,wBAETzB,EAAoBsB,UAAUI,sBAAwB,WAElD,OADAtB,KAAKO,iBAAkB,GAChB,GAEXX,EAAoBsB,UAAUG,qBAAuB,WACjD,IAAIvB,EAAQE,KAIZA,KAAKO,gBAAkBP,KAAKM,iBAAkB,EAC9C,IAAIiB,EAAOvB,KAAKwB,MAAMD,KAKtBvB,KAAKE,SAASuB,SAAQ,SAAU5C,GACvBA,EAAM6C,UAGF7C,EAAMJ,WAAaC,IAASU,WACjCP,EAAMJ,SACFI,EAAMJ,WAAaC,IAASC,QACtBD,IAASU,SACTV,IAASiD,SANnB9C,EAAMJ,SAAWC,IAASC,WASlCqB,KAAK4B,eAIL,IAAIC,EAAU,CACVC,YAAa,SAAUjD,QACS9G,IAAxB8G,EAAMkD,cACMjC,EAAMkC,SAASnD,GACrBnF,QAAQmF,EAAgB,cAAT0C,GAGrB1C,EAAMc,qBAGdsC,OAAQjC,KAAKkC,QAAQC,eASzBnC,KAAKE,SAASuB,SAAQ,SAAU5C,GAAS,OAAOiB,EAAMU,YAAY7C,IAAIkB,MACtEmB,KAAKQ,YAAY4B,MAAMP,GAIvB7B,KAAKG,OAAOsB,SAAQ,SAAUrE,GAAS,OAAOA,EAAMiB,oBAExDuB,EAAoBsB,UAAUU,aAAe,WACzC5B,KAAKG,OAAOsB,SAAQ,SAAUrE,GAAS,OAAOA,EAAMkB,0BAExDsB,EAAoBsB,UAAUN,eAAiB,SAAUD,QACvC,IAAVA,IAAoBA,GAAQ,IAC1BA,GAAUX,KAAKM,kBAKrBN,KAAKM,iBAAkB,EAIvBN,KAAKE,SAASuB,SAAQ,SAAU5C,IC9HxC,SAAqBA,GAMjB,IAJA,IAAIwD,GAAY,EAEZC,EAAc,GAETrH,EAAI,EAAGA,EAAIsH,IAAc1F,OAAQ5B,IAAK,CAC3C,IACIuH,EAAM,SADCD,IAActH,GAIpB4D,EAAM4D,SAASD,IAAsC,IAA9B3D,EAAM6D,eAAeF,KAEjDH,GAAY,EAEZC,EAAYE,GAAO3D,EAAM6D,eAAeF,GACxC3D,EAAM8D,eAAeH,EAAK,IAG9B,GAAKH,EAAL,CAMA,IAAK,IAAIG,KAFT3D,EAAM+D,aAEUN,EACZzD,EAAM8D,eAAeH,EAAKF,EAAYE,IAI1C3D,EAAM9F,kBDiGE8J,CAAYhE,GACRA,EAAMiE,wBACNjE,EAAMkE,oBAKd/C,KAAKE,SAASuB,QAAQuB,KAStBhD,KAAKG,OAAOsB,SAAQ,SAAUrE,GAAS,OAAOA,EAAMY,qBAIhD2C,GAAUX,KAAKO,kBACfP,KAAKO,iBAAkB,EACvBP,KAAKa,iBAGbjB,EAAoBsB,UAAUH,SAAW,SAAUlC,GAC/CmB,KAAKE,SAASvC,IAAIkB,GAClBmB,KAAKiD,WAAWpE,GAChBA,EAAMJ,SAAWuB,KAAKK,WAAa3B,IAASU,SAAWV,IAASiD,SAEpE/B,EAAoBsB,UAAUF,YAAc,SAAUnC,GAClDmB,KAAKY,iBACLZ,KAAKE,SAASpC,OAAOe,GACrBmB,KAAKkD,gBAAgBrE,IAEzBe,EAAoBsB,UAAU+B,WAAa,SAAUpE,GACjD,IAAIzB,EAAQ4C,KAAKgC,SAASnD,GAChB,OAAVzB,QAA4B,IAAVA,GAA4BA,EAAMO,IAAIkB,IAE5De,EAAoBsB,UAAUgC,gBAAkB,SAAUrE,GACtD,IAAIzB,EAAQ4C,KAAKgC,SAASnD,GAChB,OAAVzB,QAA4B,IAAVA,GAA4BA,EAAMS,OAAOgB,IAM/De,EAAoBsB,UAAUc,SAAW,SAAUnD,GAC/C,IAAIsE,EAAKtE,EAAMkD,cACf,QAAWhK,IAAPoL,EAIJ,OADCnD,KAAKG,OAAOiD,IAAID,IAAOnD,KAAKG,OAAOxG,IAAIwJ,EAAIlG,KACrC+C,KAAKG,OAAO3F,IAAI2I,IAE3BvD,EAAoBsB,UAAUmC,OAAS,WACnC,OAAQC,gBAAoBC,IAAoBC,SAAU,CAAElK,MAAO0G,KAAKQ,aAAeR,KAAKwB,MAAMtB,WAEtGN,EAAoB6D,YAAcC,IAC3B9D,EA/K8B,CAgLvC0D,a,gBExLa,SAASK,EAAT,GAAyB,IAATC,EAAQ,EAARA,MACvBC,EAAcC,aAAY,SAAAxG,GAAK,OAAIA,EAAMyG,OAAOF,eAChDG,EAAWC,cAEjB,OACE,qBAAKC,UAAWC,IAAMC,YAAtB,SACE,cAAC,EAAD,UACGR,EAAMS,KAAI,SAAAC,GAAO,OAChB,cAACC,EAAD,CAEEC,WAAYF,EACZ/L,SAAUsL,IAAgBS,EAC1BG,aAAc,kBAAMT,EAASU,YAAYJ,MAHpCA,UAWjB,SAASC,EAAT,GAA2D,IAAtCC,EAAqC,EAArCA,WAAYjM,EAAyB,EAAzBA,SAAUkM,EAAe,EAAfA,aACzC,OACE,sBAAKE,QAAUF,EAAeP,UAAWC,IAAMS,KAA/C,UACGJ,EACAjM,GACC,cAACsM,EAAA,EAAOC,IAAR,CACEC,SAAS,eACTb,UAAWC,IAAMa,aACjBpM,WAAYqM,OAOtB,IAAMA,EAAS,CACb1D,KAAM,SACN2D,UAAW,IACXC,QAAS,I,QClCLC,EAAe9B,IAAM+B,MAAK,kBAAM,2CAEvB,SAASC,IACtB,IAAMC,EAAczB,aAAY,SAAAxG,GAAK,OAAIA,EAAMyG,OAAOyB,qBAChD3B,EAAcC,aAAY,SAAAxG,GAAK,OAAIA,EAAMyG,OAAOF,eAChDG,EAAWC,cACXL,EAAQpF,MAAMpF,KAAK,CAACyD,OAAQ0I,EAAYE,cAAc,SAACC,EAAGC,GAAJ,OAAcA,EAAQ,KAC3ErM,EAASsM,cAATtM,MAMP,OAJAuM,qBAAU,WACR,OAAO7B,EAAS8B,YAAYxM,EAAOuK,MAClC,CAACvK,EAAOuK,IAGT,cAAC,IAAD,UACE,sBAAKK,UAAWC,IAAM4B,iBAAtB,UACE,qBAAK7B,UAAWC,IAAM6B,gBAAtB,SACE,cAACrC,EAAD,CAAOC,MAAOA,MAEhB,qBAAKM,UAAWC,IAAM8B,aAAtB,SACE,cAAC,IAAMC,SAAP,CAAgBC,SAAU,cAACC,EAAA,EAAD,IAA1B,cAC2BrO,IAAxBwN,EAAYc,SAAyBd,EAAYc,QAAQhC,KAAI,SAAAiC,GAAK,OACjE,qBAAKpC,UAAWC,IAAMoC,kBAAtB,SACE,cAACnB,EAAD,CAAckB,MAAOA,KADuBA,EAAMnD","file":"static/js/3.da3238ed.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"movieListContent\":\"MoviesList_movieListContent__340o5\",\"pages\":\"MoviesList_pages__1YOkM\",\"pageButton\":\"MoviesList_pageButton__2G7-n\",\"moviesResult\":\"MoviesList_moviesResult__3dDmj\",\"pagesConstraint\":\"MoviesList_pagesConstraint__3ArpE\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"pageNumbers\":\"Pages_pageNumbers__21Ih-\",\"active-true\":\"Pages_active-true__KYU6L\",\"link\":\"Pages_link__2d7TA\",\"selectedPage\":\"Pages_selectedPage__25Ea2\"};","import { __assign } from 'tslib';\nimport sync, { getFrameData } from 'framesync';\nimport { mix, progress, linear, mixColor, circOut } from 'popmotion';\nimport { animate } from '../../../animation/animate.js';\nimport { getValueTransition } from '../../../animation/utils/transitions.js';\nimport { motionValue } from '../../../value/index.js';\n\nfunction createCrossfader() {\n    /**\n     * The current state of the crossfade as a value between 0 and 1\n     */\n    var progress = motionValue(1);\n    var options = {\n        lead: undefined,\n        follow: undefined,\n        crossfadeOpacity: false,\n        preserveFollowOpacity: false,\n    };\n    var prevOptions = __assign({}, options);\n    var leadState = {};\n    var followState = {};\n    /**\n     *\n     */\n    var isActive = false;\n    /**\n     *\n     */\n    var finalCrossfadeFrame = null;\n    /**\n     * Framestamp of the last frame we updated values at.\n     */\n    var prevUpdate = 0;\n    function startCrossfadeAnimation(target, transition) {\n        var lead = options.lead, follow = options.follow;\n        isActive = true;\n        finalCrossfadeFrame = null;\n        var hasUpdated = false;\n        var onUpdate = function () {\n            hasUpdated = true;\n            lead && lead.scheduleRender();\n            follow && follow.scheduleRender();\n        };\n        var onComplete = function () {\n            isActive = false;\n            /**\n             * If the crossfade animation is no longer active, flag a frame\n             * that we're still allowed to crossfade\n             */\n            finalCrossfadeFrame = getFrameData().timestamp;\n        };\n        transition = transition && getValueTransition(transition, \"crossfade\");\n        return animate(progress, target, __assign(__assign({}, transition), { onUpdate: onUpdate, onComplete: function () {\n                if (!hasUpdated) {\n                    progress.set(target);\n                    /**\n                     * If we never ran an update, for instance if this was an instant transition, fire a\n                     * simulated final frame to ensure the crossfade gets applied correctly.\n                     */\n                    sync.read(onComplete);\n                }\n                else {\n                    onComplete();\n                }\n                onUpdate();\n            } }));\n    }\n    function updateCrossfade() {\n        var _a, _b;\n        /**\n         * We only want to compute the crossfade once per frame, so we\n         * compare the previous update framestamp with the current frame\n         * and early return if they're the same.\n         */\n        var timestamp = getFrameData().timestamp;\n        var lead = options.lead, follow = options.follow;\n        if (timestamp === prevUpdate || !lead)\n            return;\n        prevUpdate = timestamp;\n        /**\n         * Merge each component's latest values into our crossfaded state\n         * before crossfading.\n         */\n        var latestLeadValues = lead.getLatestValues();\n        Object.assign(leadState, latestLeadValues);\n        var latestFollowValues = follow\n            ? follow.getLatestValues()\n            : options.prevValues;\n        Object.assign(followState, latestFollowValues);\n        var p = progress.get();\n        /**\n         * Crossfade the opacity between the two components. This will result\n         * in a different opacity for each component.\n         */\n        var leadTargetOpacity = (_a = latestLeadValues.opacity) !== null && _a !== void 0 ? _a : 1;\n        var followTargetOpacity = (_b = latestFollowValues === null || latestFollowValues === void 0 ? void 0 : latestFollowValues.opacity) !== null && _b !== void 0 ? _b : 1;\n        if (options.crossfadeOpacity && follow) {\n            leadState.opacity = mix(\n            /**\n             * If the follow child has been completely hidden we animate\n             * this opacity from its previous opacity, but otherwise from completely transparent.\n             */\n            follow.isVisible !== false ? 0 : followTargetOpacity, leadTargetOpacity, easeCrossfadeIn(p));\n            followState.opacity = options.preserveFollowOpacity\n                ? followTargetOpacity\n                : mix(followTargetOpacity, 0, easeCrossfadeOut(p));\n        }\n        else if (!follow) {\n            leadState.opacity = mix(followTargetOpacity, leadTargetOpacity, p);\n        }\n        mixValues(leadState, followState, latestLeadValues, latestFollowValues || {}, Boolean(follow), p);\n    }\n    return {\n        isActive: function () {\n            return leadState &&\n                (isActive || getFrameData().timestamp === finalCrossfadeFrame);\n        },\n        fromLead: function (transition) {\n            return startCrossfadeAnimation(0, transition);\n        },\n        toLead: function (transition) {\n            var initialProgress = 0;\n            if (!options.prevValues && !options.follow) {\n                /**\n                 * If we're not coming from anywhere, start at the end of the animation.\n                 */\n                initialProgress = 1;\n            }\n            else if (prevOptions.lead === options.follow &&\n                prevOptions.follow === options.lead) {\n                /**\n                 * If we're swapping follow/lead we can reverse the progress\n                 */\n                initialProgress = 1 - progress.get();\n            }\n            progress.set(initialProgress);\n            return startCrossfadeAnimation(1, transition);\n        },\n        reset: function () { return progress.set(1); },\n        stop: function () { return progress.stop(); },\n        getCrossfadeState: function (element) {\n            updateCrossfade();\n            if (element === options.lead) {\n                return leadState;\n            }\n            else if (element === options.follow) {\n                return followState;\n            }\n        },\n        setOptions: function (newOptions) {\n            prevOptions = options;\n            options = newOptions;\n            leadState = {};\n            followState = {};\n        },\n        getLatestValues: function () {\n            return leadState;\n        },\n    };\n}\nvar easeCrossfadeIn = compress(0, 0.5, circOut);\nvar easeCrossfadeOut = compress(0.5, 0.95, linear);\nfunction compress(min, max, easing) {\n    return function (p) {\n        // Could replace ifs with clamp\n        if (p < min)\n            return 0;\n        if (p > max)\n            return 1;\n        return easing(progress(min, max, p));\n    };\n}\nvar borders = [\"TopLeft\", \"TopRight\", \"BottomLeft\", \"BottomRight\"];\nvar numBorders = borders.length;\nfunction mixValues(leadState, followState, latestLeadValues, latestFollowValues, hasFollowElement, p) {\n    /**\n     * Mix border radius\n     */\n    for (var i = 0; i < numBorders; i++) {\n        var borderLabel = \"border\" + borders[i] + \"Radius\";\n        var followRadius = getRadius(latestFollowValues, borderLabel);\n        var leadRadius = getRadius(latestLeadValues, borderLabel);\n        if (followRadius === undefined && leadRadius === undefined)\n            continue;\n        followRadius || (followRadius = 0);\n        leadRadius || (leadRadius = 0);\n        /**\n         * Currently we're only crossfading between numerical border radius.\n         * It would be possible to crossfade between percentages for a little\n         * extra bundle size.\n         */\n        if (typeof followRadius === \"number\" &&\n            typeof leadRadius === \"number\") {\n            var radius = Math.max(mix(followRadius, leadRadius, p), 0);\n            leadState[borderLabel] = followState[borderLabel] = radius;\n        }\n    }\n    /**\n     * Mix rotation\n     */\n    if (latestFollowValues.rotate || latestLeadValues.rotate) {\n        var rotate = mix(latestFollowValues.rotate || 0, latestLeadValues.rotate || 0, p);\n        leadState.rotate = followState.rotate = rotate;\n    }\n    /**\n     * We only want to mix the background color if there's a follow element\n     * that we're not crossfading opacity between. For instance with switch\n     * AnimateSharedLayout animations, this helps the illusion of a continuous\n     * element being animated but also cuts down on the number of paints triggered\n     * for elements where opacity is doing that work for us.\n     */\n    if (!hasFollowElement &&\n        latestLeadValues.backgroundColor &&\n        latestFollowValues.backgroundColor) {\n        /**\n         * This isn't ideal performance-wise as mixColor is creating a new function every frame.\n         * We could probably create a mixer that runs at the start of the animation but\n         * the idea behind the crossfader is that it runs dynamically between two potentially\n         * changing targets (ie opacity or borderRadius may be animating independently via variants)\n         */\n        leadState.backgroundColor = followState.backgroundColor = mixColor(latestFollowValues.backgroundColor, latestLeadValues.backgroundColor)(p);\n    }\n}\nfunction getRadius(values, radiusName) {\n    var _a;\n    return (_a = values[radiusName]) !== null && _a !== void 0 ? _a : values.borderRadius;\n}\n\nexport { createCrossfader };\n","import { motionValue } from '../value/index.js';\nimport { isMotionValue } from '../value/utils/is-motion-value.js';\nimport { startAnimation } from './utils/transitions.js';\n\n/**\n * Animate a single value or a `MotionValue`.\n *\n * The first argument is either a `MotionValue` to animate, or an initial animation value.\n *\n * The second is either a value to animate to, or an array of keyframes to animate through.\n *\n * The third argument can be either tween or spring options, and optional lifecycle methods: `onUpdate`, `onPlay`, `onComplete`, `onRepeat` and `onStop`.\n *\n * Returns `AnimationPlaybackControls`, currently just a `stop` method.\n *\n * ```javascript\n * const x = useMotionValue(0)\n *\n * useEffect(() => {\n *   const controls = animate(x, 100, {\n *     type: \"spring\",\n *     stiffness: 2000,\n *     onComplete: v => {}\n *   })\n *\n *   return controls.stop\n * })\n * ```\n *\n * @public\n */\nfunction animate(from, to, transition) {\n    if (transition === void 0) { transition = {}; }\n    var value = isMotionValue(from) ? from : motionValue(from);\n    startAnimation(\"\", value, to, transition);\n    return {\n        stop: function () { return value.stop(); },\n    };\n}\n\nexport { animate };\n","import { __assign } from 'tslib';\nimport { Presence } from '../types.js';\nimport { elementDragControls } from '../../../gestures/drag/VisualElementDragControls.js';\nimport { createCrossfader } from './crossfader.js';\n\nfunction layoutStack() {\n    var stack = new Set();\n    var state = { leadIsExiting: false };\n    var prevState = __assign({}, state);\n    var prevValues;\n    var prevViewportBox;\n    var prevDragCursor;\n    var crossfader = createCrossfader();\n    var needsCrossfadeAnimation = false;\n    function getFollowViewportBox() {\n        return state.follow ? state.follow.prevViewportBox : prevViewportBox;\n    }\n    function getFollowLayout() {\n        var _a;\n        return (_a = state.follow) === null || _a === void 0 ? void 0 : _a.getLayoutState().layout;\n    }\n    return {\n        add: function (element) {\n            element.setCrossfader(crossfader);\n            stack.add(element);\n            /**\n             * Hydrate new element with previous drag position if we have one\n             */\n            if (prevDragCursor)\n                element.prevDragCursor = prevDragCursor;\n            if (!state.lead)\n                state.lead = element;\n        },\n        remove: function (element) {\n            stack.delete(element);\n        },\n        getLead: function () { return state.lead; },\n        updateSnapshot: function () {\n            if (!state.lead)\n                return;\n            prevValues = crossfader.isActive()\n                ? crossfader.getLatestValues()\n                : state.lead.getLatestValues();\n            prevViewportBox = state.lead.prevViewportBox;\n            var dragControls = elementDragControls.get(state.lead);\n            if (dragControls && dragControls.isDragging) {\n                prevDragCursor = dragControls.cursorProgress;\n            }\n        },\n        clearSnapshot: function () {\n            prevDragCursor = prevViewportBox = undefined;\n        },\n        updateLeadAndFollow: function () {\n            var _a;\n            prevState = __assign({}, state);\n            var lead;\n            var follow;\n            var order = Array.from(stack);\n            for (var i = order.length; i--; i >= 0) {\n                var element = order[i];\n                if (lead)\n                    follow !== null && follow !== void 0 ? follow : (follow = element);\n                lead !== null && lead !== void 0 ? lead : (lead = element);\n                if (lead && follow)\n                    break;\n            }\n            state.lead = lead;\n            state.follow = follow;\n            state.leadIsExiting = ((_a = state.lead) === null || _a === void 0 ? void 0 : _a.presence) === Presence.Exiting;\n            crossfader.setOptions({\n                lead: lead,\n                follow: follow,\n                prevValues: prevValues,\n                crossfadeOpacity: (follow === null || follow === void 0 ? void 0 : follow.isPresenceRoot) || (lead === null || lead === void 0 ? void 0 : lead.isPresenceRoot),\n            });\n            if (\n            // Don't crossfade if we've just animated back from lead and switched the\n            // old follow to the new lead.\n            state.lead !== prevState.follow &&\n                (prevState.lead !== state.lead ||\n                    prevState.leadIsExiting !== state.leadIsExiting)) {\n                needsCrossfadeAnimation = true;\n            }\n        },\n        animate: function (child, shouldCrossfade) {\n            var _a;\n            if (shouldCrossfade === void 0) { shouldCrossfade = false; }\n            if (child === state.lead) {\n                if (shouldCrossfade) {\n                    /**\n                     * Point a lead to itself in case it was previously pointing\n                     * to a different visual element\n                     */\n                    child.pointTo(state.lead);\n                }\n                else {\n                    child.setVisibility(true);\n                }\n                var config = {};\n                var prevParent = (_a = state.follow) === null || _a === void 0 ? void 0 : _a.getProjectionParent();\n                if (prevParent) {\n                    /**\n                     * We'll use this to determine if the element or its layoutId has been reparented.\n                     */\n                    config.prevParent = prevParent;\n                }\n                if (child.presence === Presence.Entering) {\n                    config.originBox = getFollowViewportBox();\n                }\n                else if (child.presence === Presence.Exiting) {\n                    config.targetBox = getFollowLayout();\n                }\n                if (needsCrossfadeAnimation) {\n                    needsCrossfadeAnimation = false;\n                    var transition = child.getDefaultTransition();\n                    child.presence === Presence.Entering\n                        ? crossfader.toLead(transition)\n                        : crossfader.fromLead(transition);\n                }\n                child.notifyLayoutReady(config);\n            }\n            else {\n                if (shouldCrossfade) {\n                    state.lead && child.pointTo(state.lead);\n                }\n                else {\n                    child.setVisibility(false);\n                }\n            }\n        },\n    };\n}\n\nexport { layoutStack };\n","import { __extends, __assign } from 'tslib';\nimport * as React from 'react';\nimport { Presence } from './types.js';\nimport { layoutStack } from './utils/stack.js';\nimport { SharedLayoutContext } from '../../context/SharedLayoutContext.js';\nimport { MotionContext } from '../../context/MotionContext/index.js';\nimport { resetRotate } from './utils/rotate.js';\nimport { createBatcher } from './utils/batcher.js';\nimport { snapshotViewportBox } from '../../render/dom/projection/utils.js';\n\n/**\n * @public\n */\nvar AnimateSharedLayout = /** @class */ (function (_super) {\n    __extends(AnimateSharedLayout, _super);\n    function AnimateSharedLayout() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /**\n         * A list of all the children in the shared layout\n         */\n        _this.children = new Set();\n        /**\n         * As animate components with a defined `layoutId` are added/removed to the tree,\n         * we store them in order. When one is added, it will animate out from the\n         * previous one, and when it's removed, it'll animate to the previous one.\n         */\n        _this.stacks = new Map();\n        /**\n         * Track whether the component has mounted. If it hasn't, the presence of added children\n         * are set to Present, whereas if it has they're considered Entering\n         */\n        _this.hasMounted = false;\n        /**\n         * Track whether we already have an update scheduled. If we don't, we'll run snapshots\n         * and schedule one.\n         */\n        _this.updateScheduled = false;\n        /**\n         * Tracks whether we already have a render scheduled. If we don't, we'll force one with this.forceRender\n         */\n        _this.renderScheduled = false;\n        /**\n         * The methods provided to all children in the shared layout tree.\n         */\n        _this.syncContext = __assign(__assign({}, createBatcher()), { syncUpdate: function (force) { return _this.scheduleUpdate(force); }, forceUpdate: function () {\n                // By copying syncContext to itself, when this component re-renders it'll also re-render\n                // all children subscribed to the SharedLayout context.\n                _this.syncContext = __assign({}, _this.syncContext);\n                _this.scheduleUpdate(true);\n            }, register: function (child) { return _this.addChild(child); }, remove: function (child) { return _this.removeChild(child); } });\n        return _this;\n    }\n    AnimateSharedLayout.prototype.componentDidMount = function () {\n        this.hasMounted = true;\n    };\n    AnimateSharedLayout.prototype.componentDidUpdate = function () {\n        this.startLayoutAnimation();\n    };\n    AnimateSharedLayout.prototype.shouldComponentUpdate = function () {\n        this.renderScheduled = true;\n        return true;\n    };\n    AnimateSharedLayout.prototype.startLayoutAnimation = function () {\n        var _this = this;\n        /**\n         * Reset update and render scheduled status\n         */\n        this.renderScheduled = this.updateScheduled = false;\n        var type = this.props.type;\n        /**\n         * Update presence metadata based on the latest AnimatePresence status.\n         * This is a kind of goofy way of dealing with this, perhaps there's a better model to find.\n         */\n        this.children.forEach(function (child) {\n            if (!child.isPresent) {\n                child.presence = Presence.Exiting;\n            }\n            else if (child.presence !== Presence.Entering) {\n                child.presence =\n                    child.presence === Presence.Exiting\n                        ? Presence.Entering\n                        : Presence.Present;\n            }\n        });\n        this.updateStacks();\n        /**\n         * Create a handler which we can use to flush the children animations\n         */\n        var handler = {\n            layoutReady: function (child) {\n                if (child.getLayoutId() !== undefined) {\n                    var stack = _this.getStack(child);\n                    stack.animate(child, type === \"crossfade\");\n                }\n                else {\n                    child.notifyLayoutReady();\n                }\n            },\n            parent: this.context.visualElement,\n        };\n        /**\n         * Shared layout animations can be used without the AnimateSharedLayout wrapping component.\n         * This requires some co-ordination across components to stop layout thrashing\n         * and ensure measurements are taken at the correct time.\n         *\n         * Here we use that same mechanism of schedule/flush.\n         */\n        this.children.forEach(function (child) { return _this.syncContext.add(child); });\n        this.syncContext.flush(handler);\n        /**\n         * Clear snapshots so subsequent rerenders don't retain memory of outgoing components\n         */\n        this.stacks.forEach(function (stack) { return stack.clearSnapshot(); });\n    };\n    AnimateSharedLayout.prototype.updateStacks = function () {\n        this.stacks.forEach(function (stack) { return stack.updateLeadAndFollow(); });\n    };\n    AnimateSharedLayout.prototype.scheduleUpdate = function (force) {\n        if (force === void 0) { force = false; }\n        if (!(force || !this.updateScheduled))\n            return;\n        /**\n         * Flag we've scheduled an update\n         */\n        this.updateScheduled = true;\n        /**\n         * Write: Reset transforms so bounding boxes can be accurately measured.\n         */\n        this.children.forEach(function (child) {\n            resetRotate(child);\n            if (child.shouldResetTransform())\n                child.resetTransform();\n        });\n        /**\n         * Read: Snapshot children\n         */\n        this.children.forEach(snapshotViewportBox);\n        /**\n         * Every child keeps a local snapshot, but we also want to record\n         * snapshots of the visible children as, if they're are being removed\n         * in this render, we can still access them.\n         *\n         * TODO: What would be better here is doing a single loop where we\n         * only snapshotViewportBoxes of undefined layoutIds and then one for each stack\n         */\n        this.stacks.forEach(function (stack) { return stack.updateSnapshot(); });\n        /**\n         * Force a rerender by setting state if we aren't already going to render.\n         */\n        if (force || !this.renderScheduled) {\n            this.renderScheduled = true;\n            this.forceUpdate();\n        }\n    };\n    AnimateSharedLayout.prototype.addChild = function (child) {\n        this.children.add(child);\n        this.addToStack(child);\n        child.presence = this.hasMounted ? Presence.Entering : Presence.Present;\n    };\n    AnimateSharedLayout.prototype.removeChild = function (child) {\n        this.scheduleUpdate();\n        this.children.delete(child);\n        this.removeFromStack(child);\n    };\n    AnimateSharedLayout.prototype.addToStack = function (child) {\n        var stack = this.getStack(child);\n        stack === null || stack === void 0 ? void 0 : stack.add(child);\n    };\n    AnimateSharedLayout.prototype.removeFromStack = function (child) {\n        var stack = this.getStack(child);\n        stack === null || stack === void 0 ? void 0 : stack.remove(child);\n    };\n    /**\n     * Return a stack of animate children based on the provided layoutId.\n     * Will create a stack if none currently exists with that layoutId.\n     */\n    AnimateSharedLayout.prototype.getStack = function (child) {\n        var id = child.getLayoutId();\n        if (id === undefined)\n            return;\n        // Create stack if it doesn't already exist\n        !this.stacks.has(id) && this.stacks.set(id, layoutStack());\n        return this.stacks.get(id);\n    };\n    AnimateSharedLayout.prototype.render = function () {\n        return (React.createElement(SharedLayoutContext.Provider, { value: this.syncContext }, this.props.children));\n    };\n    AnimateSharedLayout.contextType = MotionContext;\n    return AnimateSharedLayout;\n}(React.Component));\n\nexport { AnimateSharedLayout };\n","import { transformAxes } from '../../../render/html/utils/transform.js';\n\nfunction resetRotate(child) {\n    // If there's no detected rotation values, we can early return without a forced render.\n    var hasRotate = false;\n    // Keep a record of all the values we've reset\n    var resetValues = {};\n    // Check the rotate value of all axes and reset to 0\n    for (var i = 0; i < transformAxes.length; i++) {\n        var axis = transformAxes[i];\n        var key = \"rotate\" + axis;\n        // If this rotation doesn't exist as a motion value, then we don't\n        // need to reset it\n        if (!child.hasValue(key) || child.getStaticValue(key) === 0)\n            continue;\n        hasRotate = true;\n        // Record the rotation and then temporarily set it to 0\n        resetValues[key] = child.getStaticValue(key);\n        child.setStaticValue(key, 0);\n    }\n    // If there's no rotation values, we don't need to do any more.\n    if (!hasRotate)\n        return;\n    // Force a render of this element to apply the transform with all rotations\n    // set to 0.\n    child.syncRender();\n    // Put back all the values we reset\n    for (var key in resetValues) {\n        child.setStaticValue(key, resetValues[key]);\n    }\n    // Schedule a render for the next frame. This ensures we won't visually\n    // see the element with the reset rotate value applied.\n    child.scheduleRender();\n}\n\nexport { resetRotate };\n","import {useDispatch, useSelector} from \"react-redux\";\r\nimport style from \"./Pages.module.css\"\r\nimport { AnimateSharedLayout, motion } from \"framer-motion\"\r\nimport {changePage} from \"../../../redux/actions/movies\";\r\n\r\nexport default function Pages({pages}) {\r\n  const currentPage = useSelector(state => state.movies.currentPage);\r\n  const dispatch = useDispatch();\r\n\r\n  return (\r\n    <div className={style.pageNumbers}>\r\n      <AnimateSharedLayout>\r\n        {pages.map(pageNum => (\r\n          <PageButton\r\n            key={pageNum}\r\n            pageNumber={pageNum}\r\n            isActive={currentPage === pageNum}\r\n            clickHandler={() => dispatch(changePage((pageNum)))}\r\n          />\r\n        ))}\r\n      </AnimateSharedLayout>\r\n    </div>\r\n  );\r\n}\r\n\r\nfunction PageButton({pageNumber, isActive, clickHandler}) {\r\n  return (\r\n    <div onClick={ clickHandler } className={style.link}>\r\n      {pageNumber}\r\n      {isActive && (\r\n        <motion.div\r\n          layoutId=\"selectedLink\"\r\n          className={style.selectedPage}\r\n          transition={spring}\r\n        />\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n\r\nconst spring = {\r\n  type: \"spring\",\r\n  stiffness: 500,\r\n  damping: 50\r\n};\r\n","import {useDispatch, useSelector} from \"react-redux\";\r\nimport style from \"./MoviesList.module.css\"\r\nimport {useParams} from \"react-router\";\r\nimport React, {useEffect} from \"react\";\r\nimport {queryMovies} from \"../../redux/actions/movies\";\r\nimport FadeIn from \"react-fade-in\";\r\nimport Pages from \"./pages/Pages\";\r\nimport LoaderPreset from \"../Loader\";\r\n\r\nconst MoviePreview = React.lazy(() => import(\"../movie-preview/MoviePreview\"));\r\n\r\nexport default function MoviesList() {\r\n  const queryResult = useSelector(state => state.movies.queryResultMovies);\r\n  const currentPage = useSelector(state => state.movies.currentPage);\r\n  const dispatch = useDispatch();\r\n  const pages = Array.from({length: queryResult.total_pages}, (_, index) => index + 1);\r\n  const {value} = useParams();\r\n\r\n  useEffect(() => {\r\n    return dispatch(queryMovies(value, currentPage));\r\n  }, [value, currentPage]);\r\n\r\n  return (\r\n    <FadeIn>\r\n      <div className={style.movieListContent}>\r\n        <div className={style.pagesConstraint}>\r\n          <Pages pages={pages}/>\r\n        </div>\r\n        <div className={style.moviesResult}>\r\n          <React.Suspense fallback={<LoaderPreset/>}>\r\n            {queryResult.results !== undefined && queryResult.results.map(movie => (\r\n              <div className={style.previewConstraint} key={movie.id}>\r\n                <MoviePreview movie={movie}/>\r\n              </div>\r\n            ))}\r\n          </React.Suspense>\r\n        </div>\r\n      </div>\r\n    </FadeIn>\r\n  );\r\n}\r\n"],"sourceRoot":""}